---
title: 'Node.js desde dentro'
date: '锔Octubre 12, 2021'
tags: '锔 Desarrollo,Informatica'
fecha: '2021-10-12'
descripcion: 'Node.js por dentro, desde V8 y libuv hasta la threadpool.'
---

# Node.js por dentro

Dos de las dependencias m谩s importantes del proyecto NodeJS son V8 y libuv.

V8 es un motor JavaScript de c贸digo abierto creado por Google. Su objetivo es ejecutar c贸digo JavaScript fuera del navegador.

libuv es una librer铆a C++ de c贸digo abierto que le da a NodeJS acceso al sistema de archivos del sistema operativo subyacente, a la red y a algunos aspectos de la concurrencia y m谩s.
```shell
C贸digo Javascriptque nosotros escribimos
 Node JS
    V8
    libuv
```

**驴Cu谩l es el prop贸sito de NodeJS en lugar de las dependencias?**

Algunas de las dependencias no son todas de JavaScript. V8 es ~70% C++ y libuv es 100% C++.

La otra cosa que hace Node es establecer un conjunto consistente de envolturas, es decir, http, fs, path, crypto, etc., que son en su mayor铆a envolturas para el proyecto libuv.

Al hacer uso de NodeJS, no tenemos que preocuparnos por el C++ subyacente.

## Implementaci贸n de m贸dulos

Para entender esto, podemos

Elegir una funci贸n en la biblioteca est谩ndar de Node

Encontrar d贸nde est谩 implementada en el c贸digo fuente de Node

Ver c贸mo se usan V8 y libuv para implementar esa funci贸n

El ejemplo que usaremos aqu铆 es pbkdf2, que es el nombre de un algoritmo de hashing que se encuentra dentro de la biblioteca 'crypto' de Nodejs.

** 驴C贸mo funciona la implementaci贸n?** Mirando en github.com, vemos que pasamos una **contrase帽a**, un **salt** y **otras opciones**.

Al comprobar la cuenta de [Github de Nodejs](https://github.com/nodejs/node), podemos comprobar que **lib** es la parte JavaScript del proyecto, mientras que **src** es la implementaci贸n C++ de todas esas funciones - aqu铆 es donde **Node** tira de **libuv**.

Te dar谩s cuenta de que la funci贸n ** pbkdf2**  de JavaScript devuelve **_pbkdf2**, que a su vez hace un mont贸n de comprobaciones de errores hasta que llegas a un bloque de c贸digo que llama a **PBKDF2**. Esta funci贸n PBKDF2 es donde C++ maneja la funci贸n.

Puedes ver que **PBKDF2** es requerido desde **process.binding('crypto')** - esa l铆nea es donde la magia ocurre entre la uni贸n de C++ con el JavaScript.

```shell
C贸digo Javascript que escribimos

 Nodos lado JS (carpeta lib en repo)

  process.binding() # conecta las funciones JS y C++

    V8 # convierte los valores entre el mundo JS y C++

       Nodos lado C++ (carpeta src en la repo)

         libuv # da a Node f谩cil acceso al SO subyacente
```

## C++ en Node

Dentro del directorio **.src** del proyecto Node en Github, podemos encontrar el archivo **.cc** equivalente a JS para el m贸dulo **node_{module-name}.cc**.

En el caso anterior, podr铆amos consultar **node_crypto.cc** para el m贸dulo Crypto.

## 驴D贸nde entran en juego V8 y libuv?

Dentro de los archivos **.cc**, ver谩s mucho **uso de v8::{name}** donde **v8** nos permite importar la definici贸n C++ de los conceptos de JavaScript.

Es m谩s dif铆cil ver la presencia de **libuv**. Si buscas en **uv** encontrar谩s trabajos como **uv_work_t** donde **libuv** se usa mucho para la concurrencia.

Ten en cuenta que hay mucha interopabilidad entre **v8**y el proyecto **libuv**.
## Los fundamentos de Threads

Cuando ejecutas algo en el ordenador, ejecutas un proceso.

Dentro de un proceso, puedes tener m煤ltiples cosas llamadas "hilos" que puedes considerar como una "lista de tareas" para que la CPU las complete.

Un solo proceso puede tener m煤ltiples hilos dentro de 茅l. Puedes saber que esto es posible gracias a cosas como el Monitor de Actividad o **Activity Monitor** que te indica el n煤mero de procesos e hilos.

La **programaci贸n** se refiere a la capacidad del SO de decidir qu茅 hilo procesar en un momento dado. Esto se vuelve relevante con muchos procesos e hilos en ejecuci贸n.

El **Programador del SO** se asegura de que los hilos no importantes no esperen demasiado tiempo.

Hay estrategias para ayudar con el proceso de que estos **hilos** sean procesados.

Un enfoque es la inclusi贸n de m谩s n煤cleos de CPU. Con m谩s n煤cleos, podemos procesar m煤ltiples hilos en paralelo.

Nota: T茅cnicamente un n煤cleo puede procesar m谩s de un hilo a la vez a trav茅s de un proceso conocido como **multithreading** (a veces llamado **hyperthreading**).

Mientras un hilo est谩 procesando y esperando una respuesta as铆ncrona, el programador del sistema operativo puede programar otro hilo para trabajar. Esto es importante para el event loop  de Nodejs.


## El event loop de Nodejs

El event loop  es utilizado por Node para manejar el c贸digo as铆ncrono escrito en nuestras aplicaciones.

Cuando iniciamos un programa Node, Node crea autom谩ticamente un hilo y ejecuta todo el c贸digo en ese hilo.

El famoso **event loop** en s铆 mismo es como una estructura de control que le dice al hilo lo que debe hacer en cada momento.

Cada programa que ejecutamos tiene exactamente un **event loop**. Es muy importante saber esto para entender c贸mo se comporta el programa, lo que a su vez nos ayudar谩 con los problemas de rendimiento.

Entenderlo no es f谩cil - pero es notoriamente dif铆cil de entender.

En lugar de ver diagramas complicados, escribiremos algo de pseudoc贸digo para emular el event loop.
```javascript
// nodo miArchivo.js
const pendingTimers = [];
const pendingOSTasks = [];
const pendingOperations = [];

// Los nuevos temporizadores, tareas y operaciones se registran a partir de la ejecuci贸n de myFile
myFile.runContents();

function shouldContinue() {
  // El nodo hace tres comprobaciones

  // Comprobaci贸n 1: 驴Hay alg煤n registro de funciones con setTimeout, setInterval o setImmediate?

  // Comprobaci贸n 2: Comprueba si hay alguna tarea pendiente del SO, por ejemplo, un servidor http escuchando peticiones en alg煤n puerto

  // Comprobaci贸n 3: 驴Hay alguna operaci贸n pendiente de larga duraci贸n que a煤n se est茅 ejecutando, por ejemplo, una llamada a una funci贸n dentro del m贸dulo fs?

  return pendingTimers.length || pendingOSTasks.length || pendingOperations.length;
}

// seudo imitaci贸n del bucle de eventos "tick" para cada iteraci贸n - ejecuta todo el cuerpo en un "tick"
while(shouldContinue()) {
  // 1) El nodo mira en pendingTimers y ve si hay alguna funci贸n lista para ser llamada (setTimeout, setInterval)

  // 2) El nodo mira los pendingOSTasks y pendingOperations y llama a los callbacks relevantes

  // 3) El nodo pausa la ejecuci贸n temporalmente y se sienta a esperar que ocurran nuevos eventos. Contin煤a cuando ...
  // - se realice una nueva pendingOSTask
  // - se realice una nueva pendingOperation
  // - un temporizador est茅 a punto de completarse

  // 4) El nodo vuelve a mirar los pendingTimers. (no se preocupa por setTimeout, setInterval - s贸lo setImmediate). Llama a cualquier setImmediate.

  // 5) Maneja cualquier evento 'close' eg readStream.on('close', callback)
}

// salir de nuevo a la terminal

```


## 驴Es Node un solo hilo?

**Event loop** de Node = monohilo

Algunas partes de Node **Framework/Std Lib** = NO son de un solo hilo

El **event loop** en s铆 mismo es realmente de un solo hilo. Esto es com煤nmente visto como algo malo, ya que el event loop s贸lo puede ejecutarse en un n煤cleo de la CPU.

Sin embargo, algunas de las funciones incluidas en la biblioteca est谩ndar de Node no son de un solo hilo - se ejecutan fuera del event loop.

Ejemplo:

```javascript
// thread.js

const crypto = require('crypto');


const start = Date.now();


// nota las dos llamadas siguientes ser谩n invocadas al mismo tiempo

crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('1:', Date.now() - start);

});


crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('2:', Date.now() - start);

});
```

Observa que el resultado que obtenemos es que algunos registros ocurren casi simult谩neamente (pero con el doble de tiempo), donde hay una pausa antes de que lleguen otros resultados. Este es el propio pool de hilos en acci贸n.


## Cambiar el Threadpool Size

```javascript
// thread.js

process.env.UV_THREADPOOL_SIZE = 2; // le dice a libuv que s贸lo cree dos hilos en el pool de hilos


const crypto = require('crypto');


const start = Date.now();


// nota que las dos llamadas siguientes ser谩n invocadas al mismo tiempo

crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('1:', Date.now() - start);

});


crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('2:', Date.now() - start);

});


crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('3:', Date.now() - start);

});


crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('4:', Date.now() - start);

});


crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {

  console.log('5:', Date.now() - start);

});
```

Notar谩s que la sincronizaci贸n ahora ocurre a煤n m谩s r谩pido para las dos primeras llamadas. Personalizar el pool de hilos aqu铆 ha funcionado a nuestro favor.

Si hici茅ramos esto usando el valor de **5**, notamos que las 5 llamadas se completan en un tiempo similar pero con un tiempo m谩s largo para que todas vuelvan de la finalizaci贸n.

## Preguntas comunes sobre Threadpool
驴Podemos utilizar el threadpool para c贸digo JS o s贸lo se puede utilizar con ciertas funciones de NodeJS? Podemos escribir c贸digo JS personalizado que utilice el threadpool.

驴Qu茅 funciones de la **node std lib** utilizan el threadpool? Todas las funciones del m贸dulo FS, algunas cosas de criptograf铆a. Depende del sistema operativo (basado en Windows o en Unix).

驴C贸mo encaja este threadpool en el event loop? Las tareas que se ejecutan en el threadpool son las **pendingOperations** en el ejemplo del pseudoc贸digo.

## Explicaci贸n de las operaciones del SO + Delegaci贸n del SO de Libuv#.

驴Qu茅 son las **pendingOSTasks** de las que hablamos en el pseudoc贸digo?

Lo explicaremos utilizando otro benchmark.

```javascript
// async.js
const https = require('https');

const start = Date.now();

function doRequest() {
  https.request('https://www.google.com', res => {
     res.on('data', () => {});
     res.on('end', () => {
       console.log(Date.now() - start);
     });
   }).end();
}

doRequest();
doRequest();
doRequest();
doRequest();
doRequest();
doRequest();
```

Parece como si todas las llamadas a **doRequest** se completaran casi al mismo tiempo - un comportamiento claramente diferente al del grupo de hilos dado que ejecutamos la petici贸n seis veces.

Lo que vemos aqu铆 es m谩s evidencia de **libuv** en juego, pero no es el pool de hilos. Tambi茅n tiene algunas funciones que hacen uso del sistema operativo subyacente.

Ni **libuv** ni **node** tienen las operaciones para manejar la realizaci贸n de peticiones. En realidad es el sistema operativo real el que hace la petici贸n http. Debido a que el trabajo se delega en el sistema operativo, el sistema operativo decide si hacer un nuevo hilo o no. No estamos tocando el pool de hilos en absoluto en este caso.

## Preguntas comunes del SO/Async#

驴Qu茅 funciones de la **node std lib** utilizan las caracter铆sticas as铆ncronas del SO? Casi todo en torno a la red para todos los sistemas operativos. Algunas otras cosas son espec铆ficas del SO.

驴C贸mo encaja este sistema operativo as铆ncrono en el event loop? Las tareas que utilizan el SO subyacente se reflejan en nuestro array **pendingOSTasks**.

## Comportamiento del Nodo Loco #

```javascript
// multitask.js
const https = require('https');
const crypto = require('crypto');
const fs = require('fs');

const start = Date.now();

function doRequest() {
  https.request('https://www.google.com', res => {
     res.on('data', () => {});
     res.on('end', () => {
       console.log('HTTPS:', Date.now() - start);
     });
   }).end();
}

function doHash() {
  crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () => {
    console.log('Hash:', Date.now() - start);
  });
}

doRequest();

fs.readFile('multitask.js', 'utf8', () => {
  console.log('FS:' Date.now() - start);
});

// se llama espec铆ficamente 4 veces
doHash();
doHash();
doHash();
doHash();
```

N贸tese que la llamada **fs** exhibe un comportamiento realmente interesante. Dado el threadpool de **libuv** de 4, el scheduler del SO y el core threading.

Las respuestas tienen que ver con los tiempos de pausa necesarios para la funci贸n **fs.readFile**.

Dado el tama帽o del pool de hilos, la llamada a **fs** se asignar铆a al hilo #1, mientras que las siguientes tres llamadas a **doHash** se asignar铆an a los otros hilos.

El hilo #1 entonces carga la 煤ltima llamada a **doHash** mientras el hilo #1 descarga el **fs.readFile** al disco duro hasta que la llamada de retorno se complete.

Una vez que el hilo #2 termina el trabajo, comprueba si ha llegado alguna informaci贸n del **disco duro** (que s铆 ha llegado), por lo que la funci贸n **fs.readFile** se completa. Nota: tiene un segundo callback de pausa, pero dado que el hilo de trabajo estaba libre, fue capaz de manejar la segunda respuesta directamente.

Tenga en cuenta que la configuraci贸n de **process.env.UV_THREADPOOL_SIZE = 5;** permitir铆a a **fs** tener un hilo de reserva para completar r谩pidamente con las otras cuatro llamadas **doHash** terminando en un plazo de tiempo similar, mientras que **process.env.UV_THREADPOOL_SIZE = 1;** bloquear铆a la llamada **fs** de terminar hasta justo al final.

